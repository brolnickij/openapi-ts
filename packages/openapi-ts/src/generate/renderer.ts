import type {
  CodegenFile,
  ICodegenFile,
  ICodegenImport,
  ICodegenMeta,
  ICodegenOutput,
  ICodegenRenderer,
} from '@hey-api/codegen-core';
import ts from 'typescript';

import { tsc } from '../tsc';
import { tsNodeToString } from '../tsc/utils';

export class TypeScriptRenderer implements ICodegenRenderer {
  id = 'typescript';

  render(file: CodegenFile, meta?: ICodegenMeta): ICodegenOutput {
    const extension = file.meta.extension ?? '';
    return {
      content: this.renderFile(file, meta),
      meta: file.meta,
      path: `${file.path}${extension}`,
    };
  }

  private groupByKey(
    file: ICodegenFile,
    group: 'exports' | 'imports',
    meta?: ICodegenMeta,
  ): Map<string, Array<ICodegenImport>> {
    const grouped = new Map<string, Array<ICodegenImport>>();

    for (const value of file[group]) {
      const shouldAppendJs =
        meta?.moduleResolution === ts.ModuleResolutionKind.NodeNext;
      const key =
        typeof value.from === 'string'
          ? value.from
          : `${file.relativePathToFile(value.from)}${shouldAppendJs ? '.js' : ''}`;
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key)!.push(value);
    }

    return grouped;
  }

  private renderFile(file: ICodegenFile, meta?: ICodegenMeta): string {
    if (!file.hasContent()) {
      return '';
    }
    const result = [
      this.renderHeaders(),
      this.renderImports(file, meta),
      this.renderSymbols(file),
      this.renderExports(file, meta),
    ]
      .filter(Boolean)
      .join('\n');
    return result.endsWith('\n') ? result : `${result}\n`;
  }

  private renderHeaders(): string {
    return ['// This file is auto-generated by @hey-api/openapi-ts', ''].join(
      '\n',
    );
  }

  private renderExports(file: ICodegenFile, meta?: ICodegenMeta): string {
    const grouped = this.groupByKey(file, 'exports', meta);
    const statements: Array<string> = [];

    for (const [from, group] of grouped.entries()) {
      const isTypeOnly = group.every(
        (value) =>
          value.typeDefaultImport ||
          value.typeNamespaceImport ||
          value.names?.every((name) => value.typeNames?.includes(name)),
      );

      if (group.length === 1 && group[0]!.namespaceImport) {
        const exportClause =
          typeof group[0]!.namespaceImport === 'string'
            ? ts.factory.createNamespaceExport(
                tsc.identifier({ text: group[0]!.namespaceImport }),
              )
            : undefined;
        const node = ts.factory.createExportDeclaration(
          undefined,
          false,
          exportClause,
          tsc.stringLiteral({ isSingleQuote: true, text: from }),
        );
        statements.push(tsNodeToString({ node }));
        continue;
      }

      const namedSpecifiers: Array<ts.ExportSpecifier> = [];
      for (const value of group) {
        for (const name of value.names ?? []) {
          const alias = value.aliases?.[name];
          const spec =
            alias && alias !== name
              ? ts.factory.createExportSpecifier(
                  false,
                  tsc.identifier({ text: name }),
                  tsc.identifier({ text: alias }),
                )
              : ts.factory.createExportSpecifier(
                  false,
                  undefined,
                  tsc.identifier({ text: name }),
                );
          namedSpecifiers.push(spec);
        }
      }

      const node = ts.factory.createExportDeclaration(
        undefined,
        isTypeOnly,
        ts.factory.createNamedExports(namedSpecifiers),
        tsc.stringLiteral({ isSingleQuote: true, text: from }),
      );
      statements.push(tsNodeToString({ node }));
    }

    if (statements.length) {
      statements.push('');
    }

    return statements.join('\n');
  }

  private renderImports(file: ICodegenFile, meta?: ICodegenMeta): string {
    const grouped = this.groupByKey(file, 'imports', meta);
    const statements: Array<string> = [];

    for (const [from, group] of grouped.entries()) {
      const specifiers: Array<ts.ImportSpecifier> = [];
      let defaultImport: ts.Identifier | undefined;
      let namespaceImport: ts.NamespaceImport | undefined;
      let isTypeOnly = false;

      for (const value of group) {
        if (value.defaultImport) {
          defaultImport = tsc.identifier({ text: value.defaultImport });
          if (value.typeDefaultImport) {
            isTypeOnly = true;
          }
        }

        if (typeof value.namespaceImport === 'string') {
          namespaceImport = ts.factory.createNamespaceImport(
            tsc.identifier({ text: value.namespaceImport }),
          );
          if (value.typeNamespaceImport) {
            isTypeOnly = true;
          }
        }

        if (value.names && value.names.length > 0) {
          if (
            !isTypeOnly &&
            value.names.every((name) => value.typeNames?.includes(name))
          ) {
            isTypeOnly = true;
          }

          for (const name of value.names) {
            const alias = value.aliases?.[name];
            const id = tsc.identifier({ text: name });
            const spec =
              alias && alias !== name
                ? ts.factory.createImportSpecifier(
                    isTypeOnly
                      ? false
                      : (value.typeNames?.includes(name) ?? false),
                    id,
                    tsc.identifier({ text: alias }),
                  )
                : ts.factory.createImportSpecifier(
                    isTypeOnly
                      ? false
                      : (value.typeNames?.includes(name) ?? false),
                    undefined,
                    id,
                  );
            specifiers.push(spec);
          }
        }
      }

      const importClause = ts.factory.createImportClause(
        isTypeOnly,
        defaultImport,
        namespaceImport ??
          (specifiers.length
            ? ts.factory.createNamedImports(specifiers)
            : undefined),
      );

      const node = ts.factory.createImportDeclaration(
        undefined,
        importClause,
        tsc.stringLiteral({ isSingleQuote: true, text: from }),
      );
      statements.push(tsNodeToString({ node }));
    }

    if (statements.length) {
      statements.push('');
    }

    return statements.join('\n');
  }

  private renderSymbols(file: ICodegenFile): string {
    const results: Array<string> = [];
    for (const symbol of file.symbols) {
      if (!symbol.value) continue;
      if (typeof symbol.value === 'string') {
        results.push(symbol.value);
      } else {
        results.push(`${tsNodeToString({ node: symbol.value as any })}\n`);
      }
    }
    return results.join('\n');
  }
}
